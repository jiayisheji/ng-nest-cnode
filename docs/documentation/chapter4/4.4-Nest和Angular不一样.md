# Nest 和 Angular 不一样

即使`Nest.js`广泛基于`Angular`，它们之间也存在重大差异。 在`Angular`中，每个服务都是一个单一实例，与`Nest.js`相同，但是可以要求`Angular`提供该服务的新实例。 要在`Angular`中做到这一点，可以使用`@Injectable()`装饰器的`providers`属性，以在模块中注册一个提供者的新实例，并且该实例仅可用于此组件。这对于避免通过不同的组件覆盖某些属性很有用。

## Nest

Nest 的依赖注入总是基于模块的。并不遵循请求/响应多线程无状态模型，在该模型中，每个请求都由单独的线程处理。因此，使用单例实例对于我们的应用程序是完全安全的。

然而，在某些情况下，基于请求的生命周期可能是所需的行为，例如GraphQL应用程序中的每个请求缓存、请求跟踪和多租户。注入范围提供了一种机制来获得所需的提供者生存期行为。

### Provider scope

提供程序可以具有以下任何作用域：

- SINGLETON：提供者的单个实例在整个应用程序中共享。实例的生命周期直接绑定到应用程序的生命周期。一旦应用程序启动，所有单例提供程序都已实例化。默认情况下使用单例范围。
- REQUEST：将为每个传入请求专门创建提供者的新实例。 请求完成处理后，实例将被垃圾回收。
- TRANSIENT：临时提供程序不跨消费者共享。 注入临时提供者的每个消费者都将收到一个新的专用实例。

> 这里我用的最多就是 `REQUEST`, 之前服务里面需要使用 `request`, 必须要使用控制器传递过去，比如获取当前用户，现在可以直接在服务里面获取当前用户，非常方部。

### Angular

在angular应用中，有一些根注入器，其中包含了所有合并的提供者，每个组件都有自己的注入器，而延迟加载的模块会引入新的注入器。

Angular 里面依赖注入可以是服务，也是可以组件/指令。我们可以使用依赖注入方式来进行组件通讯。

组件/指令中注入服务，会带有销毁的钩子，供我们清理工作，取消订阅，防止内存泄漏。

组件内注入服务，只供当前组件和子组件使用，其他组件使用就会抛出异常。

组件内注入服务，每次都创建一个新的实例。因为组件销毁服务也被销毁了。

> Nest 和 Angular 除了在写法上一样，内部实现上还是有差别的。Angular 有分级注入，惰性注入，组件也可以相互注入，Nest 只有服务可以注入。
# Passport

登录认证（鉴权），是每个应用都需要的基础功能。但很多的时候，都被大家所忽略，不仅安全漏洞验证，而且代码耦合高，混乱不堪。Passport 真是为了解决登录认证的事情，让认证模块透明易用。

总所周知，`HTTP` 请求是无状态的，我们需要知道谁操作这个请求，并且有没有权限操作这个请求。我们就需要有一个凭证：

什么是凭证呢？

凭证（Credential）是应用进行受限操作时的凭据。比如使用生活中使用信用卡付款时，输入密码和签名就是凭证。

从基于计算机的应用出现伊始，几乎每个开发者在其职业生涯内都会面对的一个最常见也是最复杂的问题，就是安全性（security）。这类问题意味着要考虑理解由谁提供什么数据/信息，此外还有关乎时间、校验、再校验等诸如此类的很多其他方面的事情。

而和安全性相关的所有关注点都可以被分解成两类问题：认证（Authentication） 和 授权（Authorization）。

Authentication 主要是身份检查, 意思就像问你有没身份证（有没登录）-> 401

Authorization 主要是角色识别, 意思就像问你身份证的户口是不是本地人(角色是什么，有权限吗) -> 403。

虽然这两个术语常常交替着使用，但它们本质上表示了不同的功用。让我们来定义这些概念。

## 认证（Authentication）

认证是这样一种验证过程：通过让用户、网站、应用程序通过提供合法证书或验证方式，以证明他们符合自己所宣称的身份。认证经常通过用户名和密码证实，有事也会辅以一些其他的只为用户所知的信息。

## 授权（Authorization）

授权指的是一个验证某用户能访问什么的过程。在授权过程中，某用户/应用程序的权限级别被确定后，才被允许访问特定的资源模块。通常，授权发生在用户身份被认证之后。

授权是通过使用“策略（Policies）”和“规则（Rules）”来实现的。

我们拿到进出卡和门卡就是认证，我们通过进出卡和门卡进入大厦到达指定房间就是进出卡和门卡就叫授权。

结合使用认证和授权来保护系统资源。当你能证明自己的身份之前，不应该被允许访问资源；而即使证明了身份，若无访问权限，依然应被拒绝。

## 实现机制

要实现认证和授权有多种途径，但时下最流行的是 “基于令牌（token-based）” 的方法。

说起基于令牌，我们不得不提起基于`Session`方式。

### Session 认证

session 认证的流程一般如下：

1. 用户向服务器发送用户名和密码。
2. 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。
3. 服务器向用户返回一个 `session_id`，写入用户的 `Cookie`。用户随后的每一次请求，都会通过 `Cookie`，将 `session_id` 传回服务器。
4. 服务器收到 `session_id`，找到前期保存的数据，由此得知用户的身份。

缺点：

- 安全性。cookies 的安全性不好，session 是基于 cookie 来进行用户识别的，cookie 如果被截获，攻击者可以通过获取本地 cookies 进行欺骗或者利用 cookies 进行跨站请求伪造（CSRF）的攻击。
- 跨域问题。使用 cookies 时，在多个域名下，会存在跨域问题。
- 有状态。session 在一定的时间里，需要存放在服务端，因此当拥有大量用户时，也会大幅度降低服务端的性能。
- 状态问题。用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，限制了负载均衡的能力。这也意味着限制了应用的扩展能力。例如当有多台机器时，如何共享 session 也会是一个问题，也就是说，用户第一个访问的时候是服务器 A，而第二个请求被转发给了服务器 B，那服务器 B 如何得知其状态。
- 移动手机问题。现在的智能手机，包括安卓，原生不支持 cookie，要使用 cookie 挺麻烦。

### 令牌认证

基于令牌的认证和授权（Token-based authentication/authorization）是这样一种技术：当用户在某处输入一次其用户名和密码后，作为交换会得到一个唯一生成的已加密令牌。该令牌随后会替代登陆凭证，用以访问受保护的页面或资源。

这种方式的要点在于确保每个发往服务器的请求都伴随着一个已签名的令牌，服务器利用该令牌核验真实性之后才对当次请求做出响应。

一个“令牌”就是服务器生成的一段数据，包含了唯一性识别一个用户的信息，一般被生成为一长串随机字符和数字。

比如看起来可能像这样：`cc7112734bbde748b7708b0284233419`，或更复杂些比如： `eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJtZXNzYWdlIjoiSldUIFJ1bGVzISIsImlhdCI6MTQ1OTQ0ODExOSwiZXhwIjoxNDU5NDU0NTE5fQ.-yIVBD5b73C75osbmwwshQNRC7frWUYrqaTjTpza2y4`。

这个令牌本身是无意义和无用的，但结合适当的令牌化系统，就会变成保证应用安全性的重要一环。

比之于传统的 cookies 等手段，使用令牌有如下好处：

- 无状态：令牌是自包含（self-contained）的，其包含了所有用于认证的信息。这对于可扩展性是极佳的，可以让服务器从不得不存储 session 的境地中解脱
- 可以在任何地方生成：令牌的生成和校验是解耦的，让使用单独的服务器甚至不同的厂商来完成令牌的签名成为了可能的选项，如 Auth0（译注：一家 ‘Identity-as-a-service’ 提供商）
- 细粒度的访问控制：通过令牌负荷（token payload），不仅是用户可访问的资源这一项，也可以轻易制定更多用户角色和权限

## 基于 passport.js 简单的 Node.js 身份验证

[Passport](http://www.passportjs.org/) 是 Node.js 的身份验证中间件。
Passport 极其灵活和模块化，可以毫不费力地放入任何基于 Express 的 Web 应用程序中。 一套全面的策略支持使用用户名和密码，Facebook，Twitter 等进行身份验证。

`passport.js` 有策略(strategy)的概念. `Strategy` 是一些预定义的方法, 它们会在请求抵达真正的路由之前执行. 如果你定义的 `Strategy` 认定某个请求非法, 则该路由不会被执行, 而是返回 `401 Unauthorized`。

